\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,enumerate,graphicx,pgf,tikz,fancyhdr}
\usepackage{geometry}
\usepackage{tabvar}
\usepackage{fontspec}
\usepackage{dot2texi}
\usepackage{minted}
\usetikzlibrary{backgrounds}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{shapes.geometric}

\title{\centering Majeure Informatique: 
Jeu d'échecs}

\author{BOYER Timothé, MOURET Basile, HACINI Malik}
\date{26 Septembre 2023}
\renewcommand{\contentsname}{Table des Matières}

\renewcommand{\theFancyVerbLine}{
    \sffamily\textcolor[rgb]{0.5,0.5,0.5}{\scriptsize\arabic{FancyVerbLine}}}
    
    
\begin{document}
    
    
\csundef{listing}\csundef{endlisting}
\csundef{listing*}\csundef{endlisting*}

\maketitle
\tableofcontents{}

\section{Introduction}
L’objectif de ce projet est de programmer (et tester) un jeu
d’échecs qui permet à deux joueurs de s’affronter, 
chaque joueur peut être soit un humain, soit l’ordinateur via une IA
 (intelligence artificielle) . Le jeu se jouera dans un terminal, 
 et si les deux joueurs sont humains, ils utiliseront le même clavier.
\section{Conception}
\subsection{Règles traitées}
traitées: promotion, roque
non traitées : en passant
\subsection{Architecture}
Ce projet a été réalisé en utilisant les outils de la programmation orientée objet (POO).
Les différentes composantes d'un jeu d'échecs (joueurs, pieces) sont donc 
représentées par des classes.
\subsubsection{Diagramme de classe UML}
a mettre

\section{Conception}
Il y eu 2 grandes phases de développement du projet : La conception du jeu entre humains
et la mise en place de l'IA. Chaque phase à donné lieu à plusieurs algorithmes principaux que nous allons détailler.

\subsection{Conception du Jeu d'échecs}
Nous avons commencé par créer en parallèle les 3 classes constituantes du jeu:
Piece, EtatJeu et Joueurs. Ces classes sont toutes associées (CF 2.2.1), donc
nous ne les avons pas réellement rédigés indépendamment.
\subsubsection{Classe Piece}
La classe Piece et ses sous-classes sont les lieux ou les règles du jeu sont définies.
On représente chaque type de pièce par une sous-classe de la classe Piece.
Chacune de ses pieces possède sa propre méthode (overwrite) coups-possibles, qui encode les règles du jeu
qui lui sont relatives. Ces méthodes nécéssitent évidemment d'avoir accès a l'état du jeu.

Enfin, la classe Piece possède une méthode coups-légaux (donc identique pour tout les types de pièces)
qui trie une liste de coups possibles en enlevant ceux qui mettent en échec le roi.
Ces méthodes nécéssitent évidemment d'avoir accès a l'état du jeu, que nous avons donc défini par la suite.

\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm]{python}

    #PLACEHOLDER
\end{minted}

\subsubsection{Classe EtatJeu}
Nous avons d'abord mis en place le plateau, ainsi que l'affichage et la sauvegarde de celui-ci.

\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm]{python}

    #PLACEHOLDER
\end{minted}

Plusieurs choix importants ont été réalisés pour la mise en place du plateau :
Nous le représentons via un dictionnaire, contenant des coordonnées (tuple) en clé
et des pièces (objets de la classe Piece) en valeur. Cette réprésentation
possède plusieurs avantages : Il est facile d'accéder au symbole UTF-8 des pièces
pour l'affichage, à la couleur d'une pièce, ou même à ses coups possibles.

Aussi, un objet EtatJeu possède une liste de deux listes de pièces, les blanches et les noires.
L'accès au pièces noires ou blanches est réalisé en accédant au bone indice de la liste pieces via
le trait.


Nous avons ensuite ajouté les fonctions relatives à la vérification de l'état du jeu
(échec, échec et mat, égalité).

\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm]{python}

    #PLACEHOLDER
\end{minted}

\subsubsection{Classe Joueurs}
C'est la classe Joueurs qui sera l'interface entre le programme main et les
classes Piece et EtatJeu, via la méthode jouer-coup. En prévision de l'implémentation de l'IA,
on implémente une sous classe Humain, qui a sa propre méthode jouer-coup, car celle de l'IA sera différente.

\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm]{python}

    #PLACEHOLDER
\end{minted}

\subsection{IA}
A FAIRE

\subsection{Le Programme main}
Au final, le jeu doit se joueur depuis un simple script main, qui utilise nos classes
définies dans des fichiers annexes.
On définit alors une fonction partie, qui créee (à partir des choix de l'utilisateur) et fait jouer une partie à l'utilisateur.
On place ensuite cette fonction dans une boucle, et le jeu est prêt.

\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm]{python}

    #PLACEHOLDER
\end{minted}

\section{Tests}
\section{peut être un de plus jsp}
\end{document}